#pragma config(UART_Usage, UART2, uartVEXLCD, baudRate19200, IOPins, None, None) //Consider baudRate4800 and/or swapping to UART1
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
//Configure the left and right motors
#pragma config(Motor,  port2,           rightDrive,    tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port3,           leftDrive,     tmotorVex269_MC29, openLoop)
//Middle motor that allows for strafing
#pragma config(Motor,  port4,           middleDrive,   tmotorVex393_MC29, openLoop)
//The number 1000 used to appear after I2C_1/2 in the two braces below. We're still not sure why
//Also, tmotorVex393_HBridge used to be tmotorVex393_MC29 and I don't know what the differance is
//And why do we even need to say "encoder" and also "encoderPort". What do either of these things mean?!?!?
//Investigate into sedonc declaration of "encoder"
#pragma config(Motor,  port5,           armRight,      tmotorVex393_HBridge, openLoop, encoder, encoderPort, I2C_1)
#pragma config(Motor,  port6,           armLeft,       tmotorVex393_HBridge, openLoop, encoder, encoderPort, I2C_2)
//*!!Code generated by 'John Mace' configuration wizard. Use at your own risk   !!*//
//CHECK THIS
//Joystick Channels: 4 = LX, 3 = LY, 2 = RY, 1 = RX
//LP is 7 BULR
//RP is 8 BLUR
//LF is 5U and 5D
//RF is 6U and 6D


#pragma platform(VEX)

#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"
//Declare functions under this line


//Useless if DEADZONE controls don't work or aren't engaged
//Unneeded
#define JOYSTICK_DEADZONE 15
// Also consider defining DEADZONE as an integer
// and setting the motor to zero if the abs(Ch2 (or whatever))
// is less than DEADZONE

void driveEncoder(int encoderCount);


void pre_auton()
{
  //Clear encoders, set servo positions or whatever
  bStopTasksBetweenModes = true;
}

task autonomous()
{
	AutonomousCodePlaceholderForTesting();
}

task usercontrol()
{
	while (true)
	{

		// displayLCDString(1, 0, "IWasNotBuilt");
		// displayLCDString(1, 1, "ToFeelRemorse");

		//Standard Tank Controls (Left Y controls driveLeft, right Y controls driveRight)
		motor[driveRight] = (vexRT[Ch2]);
		motor[driveLeft] = (vexRT[Ch3]);

		//While left and right drivetraim motors are active
		//Set motor values to integers or something if they can't be formatted like this
		while (motor[driveLeft] != 0 && motor[driveRight] != 0) {
			// Display motor encoder values
			displayLCDNumber(0, 1, nMotorEncoder[rightArm]);
			displayLCDNumber(1, 1, nMotorEncoder[leftArm]);
			//Consider removing the wait and clear line code, as it wasen't in the while loop
			//In the example code (Then again, that didn't work either)
			wait1Msec(100);
			clearLCDLine(0);
			clearLCDLine(1);
		}

		if(vexRT[Btn5D] == 1) {
				motor[driveMiddle] = -127;
		}
		else if(vexRT[Btn6D] == 1)
		{
			motor[driveMiddle] = 127;
		}
		else if(vexRT[Btn6U] == 1)
		{
			motor[armRight] = 127;
			motor[armLeft] = 127;
		}
		else if(vexRT[Btn5U] == 1)
		{
			motor[armRight] = -127;
			motor[armLeft] = -127;
		}
		else
		{
			haltLift();
			haltDriveMiddle();
		}

		//Joystick Channels: 4 = LY, 3 = LX, 2 = RY, 1 = RX
		//I really don't know about this guys...
		//motor[driveRight] = abs(vexRT[Ch2]) > JOYSTICK_DEADZONE ? reversed ? -vexRT[Ch2] : -vexRT[Ch4] : 0;
		//motor[driveLeft] = abs(vexRT[Ch4]) > JOYSTICK_DEADZONE ? reversed ? -vexRT[Ch4] : -vexRT[Ch4] : 0;

		// Methods and ways we've tried to display Integrated Motor Encoder Values on the LCD display
		//Remember to use
		// clearLCDLine(0);
		// and
		// clearLCDLine(1);
		// and
		// wait1Msec(1000); to refresh the display
		// and even use the backlight *bLCDBacklight = true;* if that's what you want to do

		// Method 1 (Doesn't work)
		// displayLCDPos(0,1);
		// displayNextLCDNumber(SensorValue[armRight]);

		// Method 2 (Also dosen't work. We don't even know what the "6" is supposed to do)
		// while (true) {
		// 	displayLCDNumber(0, 3, nMotorEncoder[rightArm], 6);
		// 	displayLCDNumber(1, 3, nMotorEncoder[leftArm], 6);
		// }

	} //Close user control while true brace
} // Close User control brace

//Function to kill all motors on the lift
void haltLift() {
	motor[armRight] = 0;
	motor[armLeft] = 0;
}
// Function to kill all motors on the drive train
void haltDrive() {
	motor[driveRight] = 0;
	motor[leftDrive] = 0;
}

void haltDriveMiddle() {
	motor[driveMiddle] = 0;
}

void driveEncoder(int encoderCount){
	// ???
	int direction = (encoderCount > 0) ? 1 : -1;
}

void resetEncoders() {
	nMotorEncoder[armRight] = 0;
	nMotorEncoder[armLeft] = 0;
}
