#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(UART_Usage, UART2, uartVEXLCD, baudRate19200, IOPins, None, None)
//Sonars plugged into ports 4,6,8 and 10
#pragma config(Sensor, dgtl4,  sonarRight,     sensorSONAR_cm)
#pragma config(Sensor, dgtl6,  sonarLeft,      sensorSONAR_cm)
#pragma config(Sensor, dgtl8,  sonarFront,     sensorSONAR_cm)
#pragma config(Sensor, dgtl10, sonarBack,      sensorSONAR_cm)
#pragma config(Motor,  port2,           driveRightFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           driveLeftFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           driveRightBack, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           driveLeftBack, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           driveMiddle,   tmotorVex393_MC29, openLoop)

//*!!Code automatically generated by 'J0HN' configuration wizard               !!*//

	// -----------------------------------
 	//    	                             |
	//  NUMEBR CORSPONDS TO MOTOR PORT   |
	//    S INDICATES SONAR PORT         |
	//                                   |
    //   ____________S8____________      |
	//      |   |         |   |          |
	//    W |   |         |   |  W       |
	//      |   |         |   |          |
	//      |   |         |   |          |
	//      |   |         |   |          | 
	//   	|   |    W    |   |          |
	//   S6 |   |==========|   |  S4     |
	//     |   |     M6    |   |         |
	//     |   |           |   |         |
	//     | G | M3     M2 | G |         |
	//   W | S |           | S | W       |
	//     | G | M5     M4 | G |         |
	//   __|___|___________|___|___      |
	//               S10                 |
	//                                   |
	// -----------------------------------


void middleRight(){
	motor[driveMiddle] = 50;
}
void middleLeft(){
	motor[driveMiddle] = -50;
}

//Compensate for oversteering to the left
void correctLeft(){
	motor[driveRightFront] = (vexRT[Ch2]) + 60;
	motor[driveRightBack] = (vexRT[Ch2]) + 60;
	correctAlarm();
}

//Compansate for oversteering to the right
void correctRight(){
	motor[driveLeftFront] = (vexRT[Ch3]) + 60;
	motor[driveLefttBack] = (vexRT[Ch3]) + 60;
	correctAlarm();

}

void correctAlarm(){
	  PlayTone( 523,     5); wait1Msec( 103);  // Note(C5, Duration(16th))
	  PlayTone(    0,    5); wait1Msec(  52);  // Note(Rest, Duration(32th))
	  PlayTone( 440,     5); wait1Msec( 103);  // Note(A4, Duration(16th))
}

task main()
{
	while(true) {

		if (vexRT[Btn5D] == 1)
		{
			while((SensorValue(sonarRight)) < 5){
				correctRight();
			}

			while((SensorValue(sonarLeft)) < 5){
				correctLeft();
			}

		}
			
		// else{
		// 	continue
		// }
		
		if (vexRT[Btn6D] == 1)
		{
				motor[driveRightFront] = (vexRT[Ch2]) - 60;
				motor[driveRightBack] = (vexRT[Ch2]) - 60;
				motor[driveLeftFront] = (vexRT[Ch3]) - 60;
				motor[driveLeftBack] = (vexRT[Ch3]) - 60;
		}


		if(vexRT[Btn5U] == 1) {
			middleRight();
		}
		else if(vexRT[Btn6U] == 1) {
			middleLeft();
		}
		else{
			motor[driveMiddle] = 0;
		}
			motor[driveRightFront] = (vexRT[Ch2]);
			motor[driveLeftFront] = (vexRT[Ch3]);
			motor[driveRightBack] = (vexRT[Ch2]);
			motor[driveLeftBack] = (vexRT[Ch3]);

	}

}
